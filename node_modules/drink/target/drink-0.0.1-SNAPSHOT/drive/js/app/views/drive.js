define( [
	'jquery',
	'../../../../bower_components/underscore/underscore',
	'backbone',
	'i18next',
	'platform',
	'd3',
	'models/drive',
	'hbs!templates/drive',
	'moment'
], function( $, _, Backbone, i18next, Platform, d3, DriveModel, driveTemplate, moment ) {
	var DriveView = Backbone.View.extend( {
		//el: '#app',
		mapCanvas: 'mapCanvas',
		mapEl: '',
		driveId: 1314,
		events: {
			'click .showMap': 'showMap',
			'click .hideMap': 'hideMap',
			'click #exitDrive': 'back',
			'click #deleteDrive': 'deleteDrive'
		},

		initialize: function() {
			this.mapEl = '#' + this.mapCanvas;
		},

		getDrive: function( driveId ) {
			var self = this;
			this.driveId = driveId;

			this.model = new DriveModel( { 'id': this.driveId } );
			this.model.fetch( {
				success: function( model, response, options ) {
					self.render( model.toJSON() );
				},
				error: function( model, response, options ) {

					// maybe the drive has been deleted, so send them to to track a new drive
					if ( navigator && navigator.notification ) {
						navigator.notification.alert(
							i18next.t( "drive.alert.deletedDriveMessage" ),
							function() {

							},
							i18next.t( "drive.alert.deletedDriveTitle" ),
							i18next.t( "drive.alert.buttons.ok" )
						);
					} else {
						alert( i18next.t( "drive.alert.deletedDriveMessage" ) );
					}

					//self.render( {} );
					window.app.router.navigate( '/feed', true );
				}
			} );

		},

		deleteDrive: function() {
			var self = this;
			var buttons = [
				i18next.t( "drive.confirmation.buttons.delete" ),
				i18next.t( "drive.confirmation.buttons.cancel" )
			];
			var buttonDeleteIndex = 1;

			if ( Platform.platform == 'iOS' ) {
				buttons.reverse();
				buttonDeleteIndex = 2;
			}

			if ( navigator && navigator.notification ) {
				navigator.notification.confirm(
					i18next.t( "drive.confirmation.message" ),
					function( buttonIndex ) {
						if ( buttonIndex == buttonDeleteIndex ) {
							// call the model and do delete
							self.deletingDrive();
						}
					},
					i18next.t( "drive.confirmation.title" ),
					buttons
				);
			} else {

				// call the model and do delete
				self.deletingDrive();
				alert( 'Deleting drive' );
				window.app.router.navigate( '/feed', true );
			}

		},

		deletingDrive: function() {
			var self = this;

			if( navigator.mixpanel ) {
				navigator.mixpanel.track(
					'Track deleted',
					{
						'Type': self.model.driveType,
						'Rating': self.model.starRating,
						'Time': self.model.duration,
						'Distance': self.model.distance,
						'Manoeuvres': JSON.stringify( self.model.manoeuvres ),
						'Screen': 'Drive summary'
					},
					function() {

					},
					function( message ) {
						console.log( message );
					}
				);
				navigator.mixpanel.increment(
					'Total drives tracked',
					-1,
					function() { },
					function( message ) {
						console.log( 'mixpanel error' + message );
					}
				);
				navigator.mixpanel.increment(
					'Total activities',
					-1,
					function() { },
					function( message ) {
						console.log( 'mixpanel error' + message );
					}
				);
			}

			this.model.destroy( {
				success: function() {
					window.app.router.navigate( '/feed', true );
				},
				error: function() {
					if ( navigator && navigator.notification ) {
						navigator.notification.alert(
							i18next.t( "drive.alert.message" ),
							function() {

							},
							i18next.t( "drive.alert.title" ),
							i18next.t( "drive.alert.buttons.ok" )
						);
					} else {
						alert( i18next.t( "drive.alert.message" ) );
					}
				}
			} );
		},

		render: function( data ) {

			if( typeof analytics !== 'undefined' ) {
				analytics.trackView( 'Drive Stats Screen' );
			}

			$( 'body' ).removeClass();

			var self = this;
			var params = data || {};
			params.deviceWidth = $( window ).width();
			params.deviceHeight = Math.round( $( window ).height() * .4 );

			// set a height
			if ( params.deviceHeight < 300 ) {
				params.deviceHeight = 300;
			}

			if ( params.distance > 0 ) {
				params.distanceInMiles = ( params.distance * 0.621371192 ).toFixed( 2 );
			}

			if ( params.duration ) {
				params.durationHumanized = null;
				var durationHumanized = [];
				var duration = moment.duration( params.duration );

				if ( duration.hours() > 0 ) {
					durationHumanized.push( duration.hours() + 'hr' );
				}

				if ( duration.minutes() > 0 ) {
					durationHumanized.push( duration.minutes() + 'min' );
				}

				if ( duration.seconds() > 0 ) {
					durationHumanized.push( duration.seconds() + 's' );
				}
				params.durationHumanized = durationHumanized.join( ' ' );
			}

			/*window.app.headerView.render( {
				title: params.driveName
			} );*/

      params.weather.temperatureRounded = Math.floor(params.weather.temperature);
      params.averageSpeedRounded = Math.floor(params.averageSpeed);

			var compiledTemplate = driveTemplate( params );
			this.$el.html( compiledTemplate );

			setTimeout( function() {
				if ( typeof plugin != "undefined" ) {
					plugin.google.maps.Map.isAvailable( function( isAvailable, message ) {
						if ( isAvailable ) {
							self.renderMap();
						} else {
							alert( message );
						}
					});
				}
			}, 1000 );

			//this.renderStats( data );
			window.app.router.postRender( self );

      var slideAmount = 0;
      var noOfSlides = $( '.slide' ).length;
      var slideWidth = 100 / noOfSlides;

      var $slider = $( '.driveSlider' );
      $slider.css( 'width', noOfSlides * 100 + '%' );

      $( '.slide' ).each( function(){
        $( this ).css( 'width', slideWidth + '%' );
      } );

      function makeDots(){
        $( '.slide-dots' ).empty();
        if( slideAmount == 0 ) {
          var currentSlide = 0;
        } else {
          var currentSlide = Math.round( slideAmount / slideWidth );
        }

        for(var i = 0; i < noOfSlides; i++){
          if( currentSlide == i ){
            $( '.slide-dots' ).append( $( '<i class="fa fa-circle">' ) );
          } else {
            $( '.slide-dots' ).append( $('<i class="fa fa-circle-o">' ) );
          }
        }
      }

      makeDots();
      $( '.driveSlider' ).css( 'transform', 'translateX(-' + slideAmount + '%)' );
      var sliderDiv = Hammer( $( '.slideOverlay' ) );
      sliderDiv.on( 'swipeleft',function( ev ){
        if( slideAmount < Math.floor( ( slideWidth )*( noOfSlides-1 ) ) ){
          slideAmount = slideAmount + slideWidth;
        }
        makeDots();
        $( '.driveSlider' ).css( '-webkit-transform', 'translateX(-' + slideAmount + '%)' );
      } );
      sliderDiv.on( 'swiperight',function( ev ){
        if( slideAmount > 0 ) {
          slideAmount = slideAmount - 100 / noOfSlides;
        }
        makeDots();
        $( '.driveSlider' ).css( '-webkit-transform', 'translateX(-' + slideAmount + '%)' );
      } );
		},

		renderMap: function() {
			var div = document.getElementById( this.mapCanvas );
			if ( !window.app.map ) {
				window.app.map = plugin.google.maps.Map.getMap();
			}

			var modelJson = this.model.toJSON();
			var points = [];


			if ( _.isObject( modelJson.route ) && modelJson.route.locations && modelJson.route.locations.length ) {
				_.each( modelJson.route.locations, function( value ) {
					if ( typeof plugin != "undefined" ) {
						var point = new plugin.google.maps.LatLng( value.latitude - 0, value.longitude - 0 );
						points.push( point );
					}
				} );
			} else {
				console.log( ' -- NO ROUTES -- ' );
			}

			var latLngBounds = new plugin.google.maps.LatLngBounds( points );

			// get the correct zoom
			var GLOBE_WIDTH = 256; // a constant in Google's map projection
			var pixelWidth = $( window ).width();
			var west = latLngBounds.southwest.lng;
			var east = latLngBounds.northeast.lng;
			var angle = east - west;
			if ( angle < 0 ) {
				angle += 360;
			}
			var zoom = Math.floor( Math.log( pixelWidth * 360 / angle / GLOBE_WIDTH ) / Math.LN2 );

			if( zoom == 'Infinity'){
				zoom = 12;
			}

			window.app.map.setDiv( div );

			window.app.map.setOptions( {
				'camera': {
					'latLng': latLngBounds.getCenter(),
					'zoom': zoom
				}
			} );

			window.app.map.setVisible( true );
			window.app.map.refreshLayout();

			if ( points.length > 0 ) {
				// start marker
				window.app.map.addMarker( {
					'position': points[0],
					'title': "Start"
				} );

				// end marker
				window.app.map.addMarker( {
					'position': points[points.length-1],
					'title': "End"
				} );

				// draw the route
				window.app.map.addPolyline( {
					points: points,
					'color' : '#3a9ec1',
					'width': 10,
					'geodesic': true
				} );
			}
    },

		renderStats: function( data ) {
			var margin = {
				top: 15,
				right: 10,
				bottom: 10,
				left: 10,
				graphTop: 20
			};
			var width = $( window ).width() - margin.left - margin.right;
			var height = 125 - margin.top + margin.graphTop - margin.bottom;

			var x = d3.time.scale()
					.range( [ 0, width ] );

			var y = d3.scale.linear()
					.range( [ height - margin.graphTop, 0 ] );

			var xAxis = d3.svg.axis()
					.scale( x )
					.orient( "bottom" );

			var yAxis = d3.svg.axis()
					.scale( y )
					.orient( "left" );

			//console.log( data.route.locations );

			var line = d3.svg.line()
				.x( function( d ) { return x( d.timestamp ); } )
				.y( function( d ) { return y( d.speed ); } );

			var svg = d3.select( "#driveSpeed" ).append( "svg" )
				.attr( "width", width + margin.left + margin.right )
				.attr( "height", height + margin.top + margin.bottom );

			var svgTop = svg.append( "g" )
				.attr( "transform", "translate(" + margin.left + "," + margin.top + ")" );


			var locations = [];
			var maxSpeed = 0;
			var maxSpeedIndex = 0;

			// normalize the values
			_.each( data.route.locations, function( location, locationIndex ) {

				if ( location.speed != -1 ) {
					// get the DATE object from Date ISO format
					var startTime = new Date( location.timestamp );
					startTime =   new Date( startTime.getTime() + ( startTime.getTimezoneOffset() * 60000 ) );
					location.timestamp = startTime;

					// convert from meters per seconds to miles per hour
					location.speed = ( location.speed * 2.2369362920544 );

					if ( location.speed > maxSpeed ) {
						maxSpeed = location.speed;
						maxSpeedIndex = locationIndex;
					}

					locations.push( location );
				}
  		} );

			x.domain( d3.extent( locations, function( d ) { return d.timestamp; } ) );
			y.domain( d3.extent( locations, function( d ) { return d.speed; } ) );

			svgTop.append( "text" )
				.attr( "y", 6 )
				.attr( "x", 10 )
				.attr( "dy", ".31em" )
				.attr( "fill", "white" )
				.attr( "font-weight", "bold" )
				.text( i18next.t( "drive.graph.title" ) );

			svgTop.append( "text" )
				.attr( "y", 6 )
				.attr( "x", width * .5 )
				.attr( "dy", ".31em" )
				.attr( "fill", "white" )
				.text( Math.round( maxSpeed, 0 ) + 'mph' );

			svg.append( "g" )
				.attr( "transform", "translate(" + margin.left + "," + ( margin.graphTop + margin.top ) + ")" )
				.append( "path" )
				.datum( locations )
				.attr( "class", "line" )
				.attr( "d", line );
		},

		showMap: function( event ) {
			event.preventDefault();

			window.app.map.setVisible( true );
			window.app.map.refreshLayout();
		},

		hideMap: function( event ) {
			event.preventDefault();


			window.app.map.toDataURL( function( imageData ) {
				$( '<img/>', {
					src: imageData
				} ).appendTo( this.mapEl );

				//$( '#console' ).html( imageData );

			} );

			window.app.map.setVisible( false );
		},

		back: function() {
			//window.app.router.goBack();
			window.app.router.navigate( '/feed', true );
		}

	} );


	//cordova -d plugin add /path/to/MapKit --variable API_KEY="YOUR_API_KEY_FROM_GOOGLE"
	//https://github.com/imhotep/MapKit
	//AIzaSyCsjQMP27cKa_Fzkogk9_0_AcCxdFps1io

	//cordova -d plugin add https://github.com/imhotep/MapKit --variable API_KEY="AIzaSyCsjQMP27cKa_Fzkogk9_0_AcCxdFps1io"

	//keytool -v -genkey -v -keystore midrive.keystore -alias midrive -keyalg RSA -validity 10000

	//keytool -list -v -keystore ~/.android/debug.keystore

	// http://stackoverflow.com/questions/13727992/google-maps-api-v2-failed-to-load-map-could-not-contact-google-servers


	//cordova plugin add plugin.google.maps --variable API_KEY_FOR_ANDROID="AIzaSyCsjQMP27cKa_Fzkogk9_0_AcCxdFps1io"

	return DriveView;
} );
