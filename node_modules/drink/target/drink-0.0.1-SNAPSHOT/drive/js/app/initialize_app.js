( function() {	
  require( [
		'midrive_app',
		'config',
		'models/offlineRequest',
		'models/manoeuvres'
	], function( MiDriveApp, config, OfflineRequestModel, ManoeuvresModel) {
    var startApp;
    startApp = function() {
			
			var m = new MiDriveApp;
			
			//console.log(m);
			window.app = m;
			
			//document.addEventListener("deviceready", function() {
					console.log('setup analytics');
					setTimeout( function() {
						var learnerString = window.localStorage.getItem( 'learner' );
						var learner = JSON.parse( learnerString );
						
						if( typeof analytics !== 'undefined' ) {
							analytics.startTrackerWithId( config.googleAnalytics );
						}
						
						if( navigator.mixpanel ) {
							navigator.mixpanel.init(
								config.mixpanelToken,
								function() {
									navigator.mixpanel.register( { 
										"googleSenderId": config.googleSenderId,
										"badge": "true",
										"sound": "true",
										"alert": "true"
									}, function() {

									}, function( message ) {
										console.log( 'mixpanel register NOT OK' + message );
									} );
									if( learner ) {

											navigator.mixpanel.identify(
												learner.id.toString(),
												function() {

													if( ( learner.email.indexOf( 'holidayextras.com', learner.email.length - 'holidayextras.com'.length) !== -1 ) || ( learner.email.indexOf( 'midrive.com', learner.email.length - 'midrive.com'.length ) !== -1 ) ) {
													//console.log(learner.email);
													navigator.mixpanel.registerSuperProperties(
														{ '$ignore': true },
														function() {

														}, function( message ) {
															console.log( 'mixpanel ignore super property NOT OK' + message );
														}
													);

												} else {
													navigator.mixpanel.unregisterSuperProperty(
														'$ignore',
														function() {
															console.log( 'unregister' );
														},
														function( message ) {
															console.log( 'mixpanel unregister ignore super property NOT OK' + message );
														}
													);

	//												navigator.mixpanel.track( 'Open_App', {},function(){
	//													navigator.mixpanel.increment( 'has_opened_app', 1,function(){
	//
	//													},function( message ){ 'mixpanel increment NOT OK' + message}); 
	//												},function( message ){ 'mixpanel track NOT OK' + message}); 
												}

											},
											function( message ) {
												console.log( 'mixpanel identify NOT OK' + message );
											}
										);
									}	

							
								}, function( message ) {
									console.log( 'mixpanel init NOT OK' + message );
								}
							);

									/*document.addEventListener('mixpanel.push', function( event ){
										console.log("got event",event);
									})*/
							
						}
					}, 1000 );
				//},false);
			// it seams that "deviceready" is fired before it finished to load every thing
			setTimeout( function() {
				// hide the splash screen
				if ( navigator && navigator.splashscreen ) {
					navigator.splashscreen.hide();
				}
				
				// register the push notifications
				/*if ( window.plugins && window.plugins.pushNotification ) {
					window.plugins.pushNotification.register(
						function( result ) {
							alert( 'result = ' + result );
						},
						function( error ) {
							alert( 'error = ' + error );
						},
						{
							"senderID": config.googleSenderId,
							"ecb": "window.onNotification"
						}
					);
				}*/
				
				// create the off line requests database
				window.offlineRequests.prepareDb();
				
				// network connection
				document.addEventListener( "offline", window.networkOffline, false );
				document.addEventListener( "online", window.networkOnline, false );
				
				
				var manoeuvresModel = new ManoeuvresModel();
				if ( ( typeof navigator.connection != 'undefined' ) && ( navigator.connection.type != Connection.NONE ) ) {
					// only do it if we are online
					manoeuvresModel.fetch( {
						success: function( model, response ) {
							console.log( 'got the manoeuvres' );
						}
					} );
				} else {
					console.log( 'offline: can not fetch manoeuvres' );
				}
				
				
				
				
			}, 1000 );
			
			setTimeout( function() {
				if ( navigator.geolocation ) {
					// get location from cordova
					navigator.geolocation.getCurrentPosition( function( position ) {					
						lat = '' + position.coords.latitude;
						long = '' + position.coords.longitude;
						window.localStorage.setItem( 'location', lat + ',' + long );
					} );
				}
			}, 2500 );
			
      return window.app;
    };
		
		
		
		window.networkOffline = function() {
			window.isOnline = false;
		}
		
		window.networkOnline = function() {
			// send the off line requests
			window.offlineRequests.getRequests();
			
			window.isOnline = true;
			$( '.offlineNotice' ).remove();
			
			// refresh the page that you are on
			var locationArray = Backbone.history.location.href.split( '#' );
			console.log( 'here ' + JSON.stringify( locationArray ) );
			if( locationArray.length > 1 ) {
				console.log( ' -- refresh to /' + locationArray[1] );
				
				if ( locationArray[1] == 'feed' ) {
					locationArray[1] = '';
				}
				window.app.router.navigate( '/' + locationArray[1], true );
			}
		}
		
		
		window.offlineRequests = {
			db: null,
			prepareDb: function() {
				var self = this;
				self.db = openDatabase( 'offlineRequests', '1.0', 'Offline requests', 5*1024*1024 );
					
				self.db.readTransaction( function( t ) {
					t.executeSql( 'SELECT * FROM requests', [], function( t, r ) {
						
						// TODO remove demo
						//self.storeRequest( null, 'http://sandbox.midrive.com/drives', 'POST', '{"hello":"world"}' );
						
					}, function( t, e ) {

						self.db.changeVersion( '1.0', '1.0', function( tx ) {
						//db.transaction( function ( t ) {
							tx.executeSql( 'CREATE TABLE requests ( requestId INTEGER PRIMARY KEY ASC AUTOINCREMENT, id, url, method, payload )' );
						}, function( err ) {
							console.log( err );
						} );
					} );
				} );
			},
			
			storeRequest: function( id, url, method, payload ) {
				try{
					console.log( 'store request', id, url, method, payload );

					var self = this;
					self.db.transaction( function ( t ) {
						t.executeSql( 'INSERT INTO requests ( id, url, method, payload ) VALUES ( ?, ?, ?, ? )', [ id, url, method, payload ], function( tx, r ) {
								console.log( 'offlineRequests - storeRequest: OK' );
							},
							function( t, e ) {
								console.log( 'offlineRequests - storeRequest: ERROR', e );
							}

						);
					} );
				} catch( err ) {
					console.log( 'Could not store the request' );
				}
			},

			getRequests: function() {
				var self = this;
				self.db.readTransaction( function( t ) {
					t.executeSql( 'SELECT * FROM requests', [], function( tx, r ) {
						
						console.log( 'results', r );
						
						if ( r.rows && ( r.rows.length > 0 ) ) {
							for( var i = 0; i < r.rows.length; i++ ) {
								// create dummy model then do a save|fetch
								
								var request = new OfflineRequestModel( r.rows.item( i ) );
								var payload = {}; // json payload
								if ( r.rows.item( i ).payload ) {
									try{
										payload = JSON.parse( r.rows.item( i ).payload );
									} catch( err ) {
										console.log( err );
									}
								}

								request.url = r.rows.item( i ).url;

								if ( r.rows.item( i ).id ) {
									// mainly for the PUT
									request.id = r.rows.item( i ).id;
								}

								if ( r.rows.item( i ).method.toUpperCase() == 'GET' ) {
									request.fetch( {
										success: function( model, response, options ) {
											console.log( 'Fetch success' );
											// the request worked fine, let's remove it
											self.removeRequest( model.get( 'requestId' ) );
										},
										error: function( model, response, options ) {
											console.log( 'Fetch error' );
										}
									} );
								} else {
									// POST or PUT ( if we have an id )
									request.save( payload, {
										success: function( model, response, options ) {
											// remove the request from DB
											console.log( 'Save success' );
											// the request worked fine, let's remove it
											self.removeRequest( model.get( 'requestId' ) );
										},
										error: function( model, response, options ) {
											console.log( 'Save error', model.get( 'requestId' ) );
											
//											if ( model.get( 'requestId' ) == 2 ) {
//												self.removeRequest( model.get( 'requestId' ) );
//											}
											
										}
									} );
								}
							}
						} else {
							console.log( 'no requests' );
						}
						
						
					}, function( t, e ) {
						
						console.log( '(unknown: ' + e.message + ')', e );
						
						// couldn't read database
						//span.textContent = '(unknown: ' + e.message + ')';
					} );
				} );
			},

			removeRequest: function( requestId ) {
				try{
					var self = this;
					self.db.transaction( function ( t ) {
						t.executeSql( 'DELETE FROM requests WHERE requestId = ?', [ requestId ], function( tx, r ) {
								console.log( 'offlineRequests - removeRequest: OK' );
							},
							function( t, e ) {
								console.log( 'offlineRequests - removeRequest: ERROR', e );
							}
						);
					} );
				} catch( err ) {
					console.log( 'could not remove the request' );
				}
			},
			
			checkConnection: function() {
				var networkState = navigator.connection.type;

				var states = {};
				states[ Connection.UNKNOWN ]  = 'Unknown connection';
				states[ Connection.ETHERNET ] = 'Ethernet connection';
				states[ Connection.WIFI ]     = 'WiFi connection';
				states[ Connection.CELL_2G ]  = 'Cell 2G connection';
				states[ Connection.CELL_3G ]  = 'Cell 3G connection';
				states[ Connection.CELL_4G ]  = 'Cell 4G connection';
				states[ Connection.CELL ]     = 'Cell generic connection';
				states[ Connection.NONE ]     = 'No network connection';

				alert( 'Connection type: ' + states[ networkState ] );
				console.log( 'Connection type: ' + states[ networkState ] );
				return networkState;
			}
		};
		
		
		
    if ( !!window.Cordova ) {
      return document.addEventListener( "deviceready", startApp, false );
    } else {
      return startApp();
    }
  } );

} ).call( this );
