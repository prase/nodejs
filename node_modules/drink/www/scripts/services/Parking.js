'use strict';

var services = angular.module('parkedex.services');

/**
 *	Handling Parking data
 */
services.factory('ParkingService', ['Geolocation','QueryService', '$filter', '$timeout', 'MapService', '$q',function(Geolocation, QueryService, $filter, $timeout, MapService, $q) {
	
	var PIN_DIR = 'images/map/pins/';
	
	var selfRef = null;
	
	function getTimesForOne (parkingId) {
		return QueryService.callWebRemote ('getOpeningHours', {id: parkingId})
		.then (function (response) {
			if (response === false) {
				return false;
			}
			console.log (JSON.stringify (response));
			var result = [];
			// cleanup for display:
			for (var entry in response) {
				var tagname = entry;
				tagname = tagname.replace ('mondays', 'Montag');
				tagname = tagname.replace ('tuesdays', 'Dienstag');
				tagname = tagname.replace ('wednesdays', 'Mittwoch');
				tagname = tagname.replace ('thursdays', 'Donnerstag');
				tagname = tagname.replace ('fridays', 'Freitag');
				tagname = tagname.replace ('saturdays', 'Samstag');
				tagname = tagname.replace ('sundays', 'Sonntag');
				var sepPos = tagname.indexOf (' - ');
				if (sepPos >= 0) {
					tagname = tagname.substr (0, 2) + tagname.substr (sepPos, 5);
				}
				if (response[entry] === null || response[entry] === '') {
					result.push ( {tagname: tagname, content: 'geschlossen'} );
				}
				else {
					result.push ( {tagname: tagname, content: response[entry] + ' Uhr'} );
				}
			}
			return result;
		}, function (error){
			console.log (error);
			return false;
		});
	}
	
	function getPricesForOne(parkingId) {
		return QueryService.callWebRemote ('getTodayPrices', {id: parkingId})
		.then (function (response) {
			return response;
		}, function (error){
			console.log (JSON.stringify (error));
			return false;
		});
	}
	
	function calcDistance (lat, lng, latorg, lngorg) {
		
		if (!latorg) {
			if (Geolocation.getLastPoint() == null) return ' - ';
		
			latorg = Geolocation.getLastPoint().latitude;
			lngorg = Geolocation.getLastPoint().longitude;
		}
		
		
		if (latorg == null) return null;

		var radlat1 = Math.PI * lat/180;
		var radlat2 = Math.PI * latorg/180;
		//var radlon1 = Math.PI * lng/180;
		//var radlon2 = Math.PI * lngorg/180;
		var theta = lng-lngorg;
		var radtheta = Math.PI * theta/180;
		var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);
		dist = Math.acos(dist);
		dist = dist * 180/Math.PI;
		dist = dist * 60 * 1.1515;
		dist = dist * 1.609344; // to km.
		//if (unit=='N') { dist = dist * 0.8684 }
		// round to one decimal:
		dist = +(Math.round(dist * 10)/10);
		return dist;
	}
	
	var orderBy = $filter('orderBy');
	// filter the results according to the set filter:
	function orderResults () {

		selfRef.data.listAvailable = false;
		if (selfRef.data.parkings.length == 0) return;
		if (selfRef.data.orderfilterindex === false) {
			selfRef.data.parkings = orderBy (selfRef.data.parkings, 'distance', false);
		}
		else {
			selfRef.data.parkings = orderBy (selfRef.data.parkings, 'selected_price', false);
		}
		return $timeout(function () {
			selfRef.data.listAvailable = true;
			return selfRef.data.parkings;
		}, 10);
	}
	
	return {
	
		data : {
			parkings : [],
			selectedParking : null,
			lastLocation : {
				latitude: 0,
				longitude: 0
			},
			currentLocation : {
				latitude: 0,
				longitude: 0
			},
			address : '',
			showList : false,
			timeFrameIndex : 1,
			listAvailable : false, 
			orderfilterindex : false
		},
		
		timeFrames : [
			{text: '30 Minuten', hours: 0.5},
			{text: '1 Stunde', hours: 1},
			{text: '2 Stunden', hours: 2},
			{text: '3 Stunden', hours: 3},
			{text: '4 Stunden', hours: 4},
			{text: '1 Tag', hours: 24}
		],
		
		setRef : function () {selfRef = this;},
	
		count : function () {
			return this.data.parkings.length;
		},
		
		orderResults : orderResults,
		
		getById : function (id) {
			var i = this.data.parkings.length;
			while (i--) {
				if (this.data.parkings[i].id == id) return this.data.parkings[i];
			}
			return null;
		},
		
		/**
		 *	Search: Sends a search to the Webservice and returns the answer
		 *	parameters: {
		 *		address : a human readable address - setting this overrides sending lat and long
		 *		radius : in km (default: 5)
		 *		lat: latitude where to search
		 *		lng: longitude where to search
		 *	}
		**/
		search : function (params, savelocation) {
			
			// always save the coordinates in lastLocation if not requested not o do so
			if (savelocation == null){
				savelocation = true;
			}
		
			// set the self reference to retain access to own functions
			this.setRef();
			
			if (params == null){
				params = {};
			}
			
			// limit the radius so that the price calculation doesn't crash the server
			if (params.radius != null && params.radius > 5) {
				params.radius = 5;
			}
			else if (params.radius == null) {
				params.radius = 1.5;
			}
			
			// set the lat & lng if address wasn't set:
			if (params.address == null) {
				params.lat = this.data.currentLocation.latitude;
				params.lng = this.data.currentLocation.longitude;
			}
			
			// save the current location as the last location where a search was done:
			if (savelocation === true) {
				this.data.lastLocation.latitude = this.data.currentLocation.latitude;
				this.data.lastLocation.longitude = this.data.currentLocation.longitude;
			}
			
			// send the query to parkpocket phone API, return the promise as result
			return QueryService.callWebRemote('search', params).then(function (response){
				
				//console.log (response);
				selfRef.data.listAvailable = false;
				
				var result = [];
				
				// Add data to the entries:
				for (var entry in response) {
					
					
					
					// jump over the entries that have no carpark information
					// (we don't need those in a carpark app)
					if (response[entry].carpark == null){
						continue;
					}
					
					// making sure every needed array is existant:
					if (response[entry].carpark.dynamic_data == null) response[entry].carpark.dynamic_data = [];

					// converting the Price to Number Datatype:
					if (response[entry].carpark.dynamic_data.price_30_min == null){
						console.log(JSON.stringify(response[entry].carpark.dynamic_data)); 
						response[entry].carpark.dynamic_data.price_30_min = '-';
					}
					else response[entry].carpark.dynamic_data.price_30_min = Number (response[entry].carpark.dynamic_data.price_30_min);
					if (response[entry].carpark.dynamic_data.price_1 == null) response[entry].carpark.dynamic_data.price_1 = '-';
					else response[entry].carpark.dynamic_data.price_1 = Number (response[entry].carpark.dynamic_data.price_1);
					if (response[entry].carpark.dynamic_data.price_2 == null) response[entry].carpark.dynamic_data.price_2 = '-';
					else response[entry].carpark.dynamic_data.price_2 = Number (response[entry].carpark.dynamic_data.price_2);
					if (response[entry].carpark.dynamic_data.price_3 == null) response[entry].carpark.dynamic_data.price_3 = '-';
					else response[entry].carpark.dynamic_data.price_3 = Number (response[entry].carpark.dynamic_data.price_3);
					if (response[entry].carpark.dynamic_data.price_4 == null) response[entry].carpark.dynamic_data.price_4 = '-';
					else response[entry].carpark.dynamic_data.price_4 = Number (response[entry].carpark.dynamic_data.price_4);
					if (response[entry].carpark.dynamic_data.price_24 == null) response[entry].carpark.dynamic_data.price_24 = '-';
					else response[entry].carpark.dynamic_data.price_24 = Number (response[entry].carpark.dynamic_data.price_24);
					
					if (selfRef.data.timeFrameIndex === 0) response[entry].selected_price = response[entry].carpark.dynamic_data.price_30_min;
					else if (selfRef.data.timeFrameIndex === 1) response[entry].selected_price = response[entry].carpark.dynamic_data.price_1;
					else if (selfRef.data.timeFrameIndex === 2) response[entry].selected_price = response[entry].carpark.dynamic_data.price_2;
					else if (selfRef.data.timeFrameIndex === 3) response[entry].selected_price = response[entry].carpark.dynamic_data.price_3;
					else if (selfRef.data.timeFrameIndex === 4) response[entry].selected_price = response[entry].carpark.dynamic_data.price_4;
					else if (selfRef.data.timeFrameIndex === 5) response[entry].selected_price = response[entry].carpark.dynamic_data.price_24;
					
					// delete n.a from free spots field:
					if (response[entry].carpark.dynamic_data.free_spots === 'na' || response[entry].carpark.dynamic_data.free_spots == null) {
						response[entry].carpark.dynamic_data.free_spots = '-';
					}
					
					// converting the flags to booleans:
					response[entry].carpark.extras_camera = Boolean (response[entry].carpark.extras_camera);
					response[entry].carpark.extras_women_spaces = Boolean (response[entry].carpark.extras_women_spaces);
					response[entry].carpark.extras_disabled_spaces = Boolean (response[entry].carpark.extras_disabled_spaces);
					response[entry].carpark.is_ecarpark = Boolean (response[entry].carpark.is_ecarpark);
					
					if (response[entry].carpark.entrance_height == null) response[entry].carpark.entrance_height = '';
					response[entry].carpark.entrance_height += '';
					response[entry].carpark.entrance_height = response[entry].carpark.entrance_height.substr (0,4);
					
					// calculating the distance to the current position:
					response[entry].distance = Number(response[entry].distance);
					
					// add it to the result array:
					result.push (response[entry]);
				}
				
				MapService.removeMarkers ();
				if (result.length == 0){
					
					// returning in a timeout to force a redraw of the page.
					return $timeout (function () {
						// set the search location pin:
						MapService.setLocationMarker (selfRef.data.currentLocation.latitude, selfRef.data.currentLocation.longitude);
						selfRef.data.listAvailable = true;
						return null;
					}, 10);
					
				}
				selfRef.data.parkings = result;
				
				console.log (JSON.stringify (result));
				
				// set the search location pin:
				MapService.setLocationMarker (selfRef.data.currentLocation.latitude, selfRef.data.currentLocation.longitude);
	
				// order and update the contents of the list (clear old, add new) 
				// orderResults returns the response.
				return selfRef.orderResults().then (function(results) { 
					MapService.addMarkers (results); 
					return results;
				});
				//return response;
			}, function (error) {
				MapService.removeMarkers ();
				// set the search location pin:
				MapService.setLocationMarker (selfRef.data.currentLocation.latitude, selfRef.data.currentLocation.longitude);
				return $q.reject (error);
			});
		},
		
		/**
		 *	Makes a geolocation call and searches at the resulting coordinates.
		**/
		searchHere : function (params) {
			
			this.setRef ();
			return MapService.getLocation().then (function(position) {
				selfRef.data.currentLocation = {
					latitude: position.latLng.lat, 
					longitude: position.latLng.lng
				};
				return selfRef.search(params).then(
					function (response) {
						return response;
					}, 
					function (error) {
						return $q.reject (error);
					}
				);
			}, function (error) {
				return $q.reject (error);
			});
		},
		
		// change the selected price for the parkings:
		changeSelectedPrices : function () {
			var i = selfRef.data.parkings.length;
			var ti = selfRef.data.timeFrameIndex;
			while (i--) {
				if (ti == 0) selfRef.data.parkings[i].selected_price = selfRef.data.parkings[i].carpark.dynamic_data.price_30_min;
				else if (ti == 1) selfRef.data.parkings[i].selected_price = selfRef.data.parkings[i].carpark.dynamic_data.price_1;
				else if (ti == 2) selfRef.data.parkings[i].selected_price = selfRef.data.parkings[i].carpark.dynamic_data.price_2;
				else if (ti == 3) selfRef.data.parkings[i].selected_price = selfRef.data.parkings[i].carpark.dynamic_data.price_3;
				else if (ti == 4) selfRef.data.parkings[i].selected_price = selfRef.data.parkings[i].carpark.dynamic_data.price_4;
				else if (ti == 5) selfRef.data.parkings[i].selected_price = selfRef.data.parkings[i].carpark.dynamic_data.price_24;
			}
			// reorder them (to refresh the list and data on the page and change their order according to new price):
			return selfRef.orderResults ();
		},
		
		getTimesForOne : getTimesForOne,
		getPricesForOne : getPricesForOne,
		calcDistance : calcDistance
	};
}]);