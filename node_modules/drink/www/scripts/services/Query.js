'use strict';

var services = angular.module('parkedex.services');

services.factory ('QueryService', ['$http', 'SecurityService', '$q', function ($http, SecurityService, $q) {
	
	
	
	var queryAddresses = [
		// liveserver:
		'http://parkpocket.com/app/',
		
		// alternative server:
		'http://pg-test-env.elasticbeanstalk.com/app/'
	];
	
	function callWebRemote (action, data, encrypt) {
		
		// encrypt data if requested
		if (encrypt && encrypt === true) {
			data = {data : SecurityService.encrypt (data)};
		}
		
		// encrypt the data 
		//var data = SecurityService.encrypt (data);
		
		// build a query to send to the webservice
		var queryOrders = action + '?';//data=' + data;
		
		// append all entries in data object as GET params:
		for (var entry in data) {
			queryOrders += '&' + entry + '=' + data[entry];
		}
		
		console.log (queryOrders);
		
		// send the query to the webservice and return the resulting response
		return tryAllQueries (queryOrders)
		.then(
		
			function (response) {
				
				// if answer contains encrypted data, decrypt it:
				if (response.data != null && response.data !== true) {
					response = SecurityService.decrypt (response.data);
				}
				
				// move the working queryAddress to the top of the trial array:
				if (callAddressNr > 0) {
					var mov = queryAddresses[callAddressNr];
					queryAddresses.splice(callAddressNr, 1);
					queryAddresses.splice(0, 0, mov);
				}
				
				return response;
			},
			
			function (error) {
				return $q.reject(error);
			}
		).finally (function () {
			// reset the order of list of queries to call:
			callAddressNr = 0;
		});
	}
	
	// variable that says which queryAddress to call:
	var callAddressNr = 0;
	
	function tryAllQueries (queryOrders) {
		// send the query to the webservice and return the resulting response
		return $http
		.get (queryAddresses[callAddressNr] + queryOrders, {timeout: 5000})
		.then(
		
			function (response) {
				
				console.log ('response accepted from: ' + queryAddresses[callAddressNr]);
				// on success, just return the response:
				return response.data;
			},
			
			function (error) {
				
				// log the error status code:
				console.log ('error_status: ' + JSON.stringify(error.status) + ' from: ' + queryAddresses[callAddressNr]);
				
				// check if all queryAddresses were checked, if not, call the next one:
				if (callAddressNr < (queryAddresses.length-1)) {
					callAddressNr++;
					return tryAllQueries (queryOrders);
				}
				
				// if the last address gave us no result, throw the rejection and give up:
				console.log ('error connecting to the servers.');
				return $q.reject(error);
			}
		);
	}
	
	return {
		callWebRemote : callWebRemote
	};
}]);