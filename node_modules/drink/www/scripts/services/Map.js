'use strict';

var services = angular.module('parkedex.services');

services.factory ('MapService', ['$window', '$log', '$q', function ($window, $log, $q) {
	
	var map = null;
	var mapObj = null;
	var events = {};
	var ready = false;
	
	// container of all the markers on the map:
	// Carpark pins are named after their poi_id.
	var markers = [];
	
	// Flag for the current pin size:
	var pinsSmall = false;
	
	var startpromise = $q.defer ();
	var initialize = $q.defer ();
	
	var selfRef = null;
	
	var PIN_DIR = 'images/map/pins/';
	
	var fontLabelFree = "10px Roboto";
	var fontLabelFreeBig = "11px Roboto";
	var fontLabelPriceSmaller = "12px Roboto";
	var fontLabelPrice = "13px Roboto";
	var fontLabelPriceBig = "17px Roboto";
	var fontLabelEuro = "10px Roboto";
	var fontLabelEuroBig = "13px Roboto";
	
	// create a canvas for the creation of marker images:
	var canvas = document.createElement('canvas');
	canvas.width = 50;
	canvas.height = 63;
	var context = canvas.getContext('2d');
	context.fillStyle = '#FFFFFF';
	var canvasBig = document.createElement ('canvas');
	canvasBig.width = 60;
	canvasBig.height = 75;
	var contextBig = canvasBig.getContext('2d');
	contextBig.fillStyle = '#3f90cf';
	var canvasSmall = document.createElement('canvas');
	canvasSmall.width = 22;
	canvasSmall.height = 22;
	var contextSmall = canvasSmall.getContext('2d');
	
	// preload all the pin images:
	var pinBlank = new Image ();
	pinBlank.src = PIN_DIR + "pin_blank-01.png";
	var pinGreen = new Image ();
	pinGreen.src = PIN_DIR + "pin_blank_green-01.png";
	var pinRed = new Image ();
	pinRed.src = PIN_DIR + "pin_blank_red-01.png";
	
	var pinSelected = new Image();
	pinSelected.src = PIN_DIR + "pin_scale-01.png";
	var pinSelectedGreen = new Image ();
	pinSelectedGreen.src = PIN_DIR + "pin_scale_green-01.png";
	var pinSelectedRed = new Image ();
	pinSelectedRed.src = PIN_DIR + "pin_scale_red-01.png";
	
	var pinSmall = new Image ();
	pinSmall.src = PIN_DIR + "pin_small-01.png";
	var pinSmallGreen = new Image ();
	pinSmallGreen.src = PIN_DIR + "pin_small_green-01.png";
	var pinSmallRed = new Image ();
	pinSmallRed.src = PIN_DIR + "pin_small_red-01.png";
	var pinSmallBase64 = '';
	var pinSmallGreenBase64 = '';
	var pinSmallRedBase64 = '';

	var locationMarkerIcon = new Image ();
	locationMarkerIcon.src = PIN_DIR + "pin_location-01.png";
	var locationMarkerIconBase64 = null;
	
	// create a caching container for all the generated marker images:
	var markerImages = [];
	var markerImagesSelected = [];
	var markerImagesSmall = [];
	
	// a twoDimensional array that contains the pin combination for the currently loaded parkings
	// e.g. pin[66484] = [56] [3]
	//					 free price
	var parkingMarkerMap = [];
	
	// save which marker is currently selected, to preserve selection after resize:
	var selectedMarker = null;

	var locationMarker = null;
	
	// available event functions:
	//'MAP_CLICK'
	//'MAP_LONG_CLICK'
	//'MY_LOCATION_BUTTON_CLICK'
	//'CAMERA_CHANGE'
	//'CAMERA_IDLE'
	//'MAP_READY'
	//'MAP_LOADED'
	//'MAP_WILL_MOVE'
	//'MAP_CLOSE'
	
	var position = {
		latitude: 48.77582,
		longitude: 9.177661,
		zoom: 16.0
	};
	
	function updatePosition (pos) {
		//console.log (JSON.stringify(pos));
		position.latitude = pos.target.lat;
		position.longitude = pos.target.lng;
		position.zoom = pos.zoom;
		
		if (pinsSmall === false && Number(pos.zoom) < 12) {
			selfRef.shrinkMarkers ();
		}
		else if (pinsSmall === true && Number(pos.zoom) >= 12) {
			selfRef.unshrinkMarkers ();
		}
	}
	
	function requestMarkerImages (free_spots, price) {
		
		if (markerImages[free_spots] != null && markerImages[free_spots][price] != null) return;

		var free_spots_txt = '';
		if (Number (free_spots) > 99) free_spots_txt = '99+';
		else free_spots_txt = free_spots;
		
		console.log ('creating image for ' + free_spots + ', ' + price);
		
		// clear the canvas and erase the last image:
		context.clearRect ( 0 , 0 , canvas.width, canvas.height );
		contextBig.clearRect ( 0 , 0 , canvasBig.width, canvasBig.height );
		
		// draw the image on the canvases and then write text on them:
		if (free_spots == '-'){
			context.drawImage (pinBlank, 0, 0, 50, 63);
			contextBig.drawImage (pinSelected, 0, 0, 60, 75);
		}
		else{
			if ((free_spots|0) > 9) {
				context.drawImage (pinGreen, 0, 0, 50, 63);
				contextBig.drawImage (pinSelectedGreen, 0, 0, 60, 75);
				
			}
			else {
				context.drawImage (pinRed, 0, 0, 50, 63);
				contextBig.drawImage (pinSelectedRed, 0, 0, 60, 75);
			}
			
			// draw the free spots text into the normal marker
			context.font = fontLabelFree;
			var txtwidth = context.measureText(free_spots_txt).width;
			var leftside = 34 - (txtwidth/2);
			context.fillText (free_spots_txt, leftside, 14);
			
			// Draw the free spots text into the big marker
			contextBig.fillStyle = '#FFFFFF';
			contextBig.font = fontLabelFreeBig;
			txtwidth = contextBig.measureText(free_spots_txt).width;
			leftside = 40 - (txtwidth/2);
			contextBig.fillText (free_spots_txt, leftside, 15);
		}
		
		// draw the price into the normal marker
		context.font = fontLabelPrice;
		var txtwidth = context.measureText(price).width;
		if (txtwidth > 35) {
			context.font = fontLabelPriceSmaller;
			txtwidth = context.measureText(price).width;
		}
		var leftside = 25 - (txtwidth/2) - 8;
		context.fillText (price, leftside, 36);
		context.font = fontLabelEuro;
		context.fillText ('€', leftside+txtwidth +2 , 36);
		
		// Draw the price into the big marker
		contextBig.fillStyle = '#3f90cf';
		contextBig.font = fontLabelPriceBig;
		txtwidth = contextBig.measureText(price).width;
		if (txtwidth > 45) {
			contextBig.font = fontLabelPrice;
			txtwidth = contextBig.measureText(price).width;
		}
		leftside = 30 - (txtwidth/2) - 8;
		contextBig.fillText (price, leftside, 43);
		contextBig.font = fontLabelEuroBig;
		contextBig.fillText ('€', leftside+txtwidth + 2, 43);
		
		
		// create small pins in base64 format, because raw image files can't be used as pins: (if we don't have them already)
		if (pinSmallBase64 === '') {
			contextSmall.drawImage (pinSmall, 0, 0, 22, 22);
			pinSmallBase64 = canvasSmall.toDataURL();
			
			contextSmall.drawImage (pinSmallGreen, 0, 0, 22, 22);
			pinSmallGreenBase64 = canvasSmall.toDataURL();
			
			contextSmall.drawImage (pinSmallRed, 0, 0, 22, 22);
			pinSmallRedBase64 = canvasSmall.toDataURL();
			canvasSmall = null;
			contextSmall = null;
		}
		
		// save the created images in an array to have them ready for later requests:
		if (markerImages[free_spots] == null) markerImages[free_spots] = [];
		if (markerImagesSelected[free_spots] == null) markerImagesSelected[free_spots] = [];
		// save the current content of the canvasses as image in the corresponding array:
		markerImages[free_spots][price] = canvas.toDataURL();
		markerImagesSelected[free_spots][price] = canvasBig.toDataURL();
	}
	
	return {
		
		// saved position of last geolocation result
		myLocation : {
			lat: 48.77582,
			lng: 9.177661
		},
		
		// a function that is called after any marker was clicked, with the parking/marker id as parameter.
		markerClickCallback : null,
		
		//flag if map is the current page:
		isMapActiveView : true,
		
		isReady : function () {
			return ready;
		},
		
		// returns the current position of the camera.
		getPosition : function () {
			return position;
		},

		getSelectedMarkerId : function () {
			return selectedMarker;
		},
		
		init : function (id) {
			mapObj = $window.plugin.google.maps;
			selfRef = this;
			initialize.resolve (mapObj);
			
			if (id != null) {
				selfRef.connectToDiv (id);
			}
			return startpromise.promise;
		},
		
		connectToDiv : function (id) {
			var div = $window.document.getElementById(id);
			map = $window.plugin.google.maps.Map.getMap(div);
			
			// binding the events to the map
			for (var key in events) {
				var evtName = mapObj.event[key];
				$log.log('adding listener to ' + evtName);
				map.on (evtName, events[key]);
			}
			ready = true;
			
			// map event causes ios app to freeze:
			map.on (mapObj.event['CAMERA_CHANGE'], function (pos) {
				//console.log (JSON.stringify(pos));
				position.latitude = pos.target.lat;
				position.longitude = pos.target.lng;
				position.zoom = pos.zoom;
				
				if (pinsSmall === false && pos.zoom < 12) {
					selfRef.shrinkMarkers ();
				}
				else if (pinsSmall === true && pos.zoom >= 12) {
					selfRef.unshrinkMarkers ();
				}
			});
			
			startpromise.resolve(map);
		},
		getMap : function () {
			console.log('getMap called.');
			return map;
		},
		getObject : function () {
			return mapObj;
		},
		setEvent :function (eventName, eventFkt) {
			// if the map is already ready, bind the function to the element itself
			if (ready) {
				var evtName = mapObj.event[eventName];
				map.on (evtName, eventFkt);
				$log.log(eventName + ' set');
			}
			// if the map is not ready yet, put them in the event buffer.
			else {
				events[eventName] = eventFkt;
				$log.log ('saving event ' + eventName + ' for later');
			}
			
		}, 
		goToPoint : function (lat, lng) {

			var p = new mapObj.LatLng(lat, lng);
			map.moveCamera({
				'target': p,
				'zoom': 16
			}); 
		},
		moveToPoint : function (lat, lng) {
			var p = new mapObj.LatLng(lat, lng);
			map.animateCamera({
				'target': p,
				'zoom': 16
			}); 
		},
		onInit : function () {
			return initialize.promise;
		},
		onReady : function () {
			return startpromise.promise;
		}, 
		getLocation : function () {
			var locationPromise = $q.defer ();
			map.getMyLocation(function(position) {
				selfRef.myLocation.lat = position.latLng.lat;
				selfRef.myLocation.lng = position.latLng.lng;
				locationPromise.resolve (position);
			}, function (error) {
				locationPromise.reject (error);
			});
			return locationPromise.promise;
		},
		
		/** --------------------------------------------------
								MARKERS
		*** ------------------------------------------------*/
		
		// adding one marker:
		addParkingMarker : function (lat, lng, id, free_spots, price, icon_type) {
			
			var width = 0;
			var height = 0;

			// create all the pins for the new parkings:
			requestMarkerImages (free_spots, price);
			
			// save the pin information in parkingMarkerMap.
			parkingMarkerMap[id] = [free_spots, price, lat, lng];
			
			if (icon_type == null) icon_type = 'normal';

			// get the icon for this carpark:
			var icon = null;
			if (icon_type === 'normal'){
				icon = markerImages[free_spots][price]; 
				width = 50;
				height = 63;
			}
			else if (icon_type === 'small') {
				if (free_spots == '-') {
					icon = pinSmallBase64;
				}
				else if (Number (free_spots) > 9) {
					icon = pinSmallGreenBase64;
				}
				else {
					icon = pinSmallRedBase64; 
				}
				width = 60;
				height = 75;
			}
			else if (icon_type === 'big') {
				icon = markerImagesSelected[free_spots][price];
				width = 22;
				height = 22;
			}
			
			var obj = {
				snippet: '', 
				draggable: false, 
				position: new mapObj.LatLng (lat, lng), 
				icon: icon, 
				id: id, 
				disableAutoPan: true
			};
			
			var markerReady = $q.defer();
			
			map.addMarker(obj, function (m) {
				
				m.setIcon ({'size': {
			        width: width,
			        height: height
			    }});
				// callback function after new marker is created (m is new marker instance)
				console.log ('adding parking with id ' + obj.id);
				m.addEventListener (mapObj.event.MARKER_CLICK, function (id) {
					console.log (JSON.stringify(id));
						
					// set the active marker on the MapService Object to the pin id:
					selfRef.activeMarkerId = id;
						
					// activate the callback function for setting a new pin:
					if (typeof selfRef.markerClickCallback === 'function') {
						selfRef.markerClickCallback.call(undefined, id);
					}
				}.bind(selfRef, obj.id));
				
				markers[obj.id] = m;
				markerReady.resolve (m);
			});
			
			return markerReady.promise;
		},
		
		// add a bunch of new markers to the map:
		addMarkers : function (parkingArray) {
			if (parkingArray == null) return;
			var l = parkingArray.length;
			while (l--) {
				if (parkingArray[l].id  === selectedMarker) selfRef.addParkingMarker (parkingArray[l].lat, parkingArray[l].lng, parkingArray[l].id, parkingArray[l].carpark.dynamic_data.free_spots, parkingArray[l].selected_price, 'big');
				else selfRef.addParkingMarker (parkingArray[l].lat, parkingArray[l].lng, parkingArray[l].id, parkingArray[l].carpark.dynamic_data.free_spots, parkingArray[l].selected_price, 'normal');
			}
		},
		
		// remove all the pins from the map:
		removeMarkers : function () {
			map.clear ();
			/*markers.forEach (function (marker, index, array) {
				marker.remove ();
			});*/
			//map.clear ();
			markers = [];
			//if (locationMarker != null) locationMarker.remove();
		},
		
		// change the images of the current pins on the map:
		updateMarkerImages : function (parkingArray) {
			var index = parkingArray.length;
			console.log (JSON.stringify (parkingArray [0]));
			while (index--) {
				if (parkingArray[index] == null) continue;
				var f = parkingArray[index].carpark.free_spots;
				var p = parkingArray[index].selected_price;
				
				// create all the pins for the new parkings:
				requestMarkerImages (f, p);
				
				// if a marker is selected, don't set his pin to his normal pin, but to the selected one:
				if (parkingArray[index].id === selectedMarker) {
					selfRef.changeMarkerImage(parkingArray[index].id, 'big');
				}
				else selfRef.changeMarkerImage(parkingArray[index].id, 'normal');

			}
		},
		
		selectMarker : function (id) {
			selectedMarker = id;
			if (pinsSmall === true) return;
			selfRef.changeMarkerImage(id, 'big');
		},
		
		unselectMarker : function (id) {
			selectedMarker = null;
			if (pinsSmall === true) return;
			selfRef.changeMarkerImage(id, 'normal');
		}, 
		
		shrinkMarkers : function () {

			markers.forEach (function (marker, index, array) {
				if (marker != null) {
					// if the price of the carpark is below 9:
					selfRef.changeMarkerImage(index, 'small');
					
					console.log ('shrinked marker ' + index + '?');
				}
			});
			pinsSmall = true;
		}, 
		
		unshrinkMarkers : function () {
			markers.forEach (function (marker, index, array) {
				if (marker != null) {
					var p = parkingMarkerMap[index][1];
					var f = parkingMarkerMap[index][0];
					
					// if a marker is selected, don't set his pin to his normal pin, but to the selected one:
					if (index === selectedMarker) {
						selfRef.changeMarkerImage(index, 'big');
					}
					else selfRef.changeMarkerImage(index, 'normal');
				}
			});
			pinsSmall = false;
		},
		// an own implementation of a change marker image function, since the plugin one crashes iOS.
		changeMarkerImage : function (index, icon_type) {
			console.log (JSON.stringify (markers[index]));
			var p = parkingMarkerMap[index][1];
			var f = parkingMarkerMap[index][0];
			var lat = parkingMarkerMap[index][2];
			var lng = parkingMarkerMap[index][3];
			
			markers[index].setOpacity(0);
			markers[index].setVisible (false);
			markers[index].remove ();
			markers[index] = null;
			selfRef.addParkingMarker (lat, lng, index, f, p, icon_type).then (function (m) {
				markers[index] = m;
			});
		}, 
		setLocationMarker : function (lat, lng) {
			
			// delete last location marker if set:
			if (locationMarker != null) locationMarker.remove();
			
			// create image if it does not exist:
			if (locationMarkerIconBase64 == null) {
				context.clearRect (0, 0, 50, 63);
				context.drawImage (locationMarkerIcon, 0, 0, 50, 63);
				locationMarkerIconBase64 = canvas.toDataURL();
			}

			var obj = {
				snippet: '', 
				draggable: false, 
				position: new mapObj.LatLng (lat, lng), 
				icon: locationMarkerIconBase64, 
				disableAutoPan: true
			};
			
			map.addMarker(obj, function (m) {
			
				// callback function after new marker is created (m is new marker instance)
				locationMarker = m;
			});
		}
	};
}]);